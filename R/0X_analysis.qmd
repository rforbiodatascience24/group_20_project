---
title: "0X_analysis"
author: Antoine Andréoletti, Olivier Gaufrès, Amy Surry, Lea Skytthe, Trine Søgaard
format:
  html:
    embed-resources: true
editor: visual
---

# Analysis

```{r}
#| label: setup
#| include: false

# rm(list=ls())

library("tidyverse")
library("pheatmap")
library("ggplot2")
library("ggrepel")

## DEA libraries
library("DESeq2")

source(file.path("99_proj_func.R"))
```

## Load data

### Load phenotype

```{r}
#| label: load-pheno
#| include: false
#| echo: true

data_pheno <- read.csv("../data/02_metadata_clean.csv")

# We want patients as row names, so we convert the tibble to a dataframe and names the rows
data_pheno <- data.frame(data_pheno) |> 
  column_to_rownames("source_name")

#files <- data_pheno |> mutate(file = str_c("data/_raw/count_data/",source_name, "_quant.sf"))
```

### Load counts matrix

```{r}
#| label: load-counts
#| include: false
#| echo: true

data_counts <- read.csv("../data/02_normalized_count_data_wide.csv")
# We want genes as row names, so we convert the tibble to a dataframe and names the rows
data_counts <- data.frame(data_counts) |>
  column_to_rownames("Name")

colnames(data_counts) <- colnames(data_counts) |> substring(2)

# The output of the mapping algorithm they use is an estimated number of reads mapped to each gene. It is a float while we need an integer. We will then convert it.
data_counts <- data_counts |> 
  mutate(across(where(is.numeric), as.integer))
```

## Differential Expression Analysis

### Using DESeq2

We need to make sure that the rows of the metadata corresponds to the columns of the count data

```{r}
common_samples <- intersect(colnames(data_counts), rownames(data_pheno))

data_pheno <- data_pheno[common_samples,]
data_counts <- data_counts[,common_samples]
```

```{r}
#| label: dea-deseq2
#| include: false
#| echo: true

dds <- DESeqDataSetFromMatrix(countData = data_counts,
                              colData = data_pheno,
                              design = ~ disease)

# dds <- DESeqDataSetFromMatrix(countData = data_counts,
#                               colData = data_pheno,
#                               design = ~ disease + clinical_information)


dds
featureData <- data.frame(gene=rownames(data_counts))
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)

## Pre=filtering
smallestGroupSize <- 3
keep <- rowSums(counts(dds) >= 10) >= smallestGroupSize
dds <- dds[keep,]

## Adding the reference level (normal)
dds$disease <- relevel(dds$disease, ref = "normal")

## DEA
dds <- DESeq(dds)
res <- results(dds)
res

```

### PCA

```{r}
#| label: pca-individual
## Transpose the counts matrix to have the PCA for individuals and not gene expression
pca <- prcomp(t(data_counts))

## Proportion of variance
PoV <- pca$sdev^2/sum(pca$sdev^2)
PoV <- PoV * 100
PoV <- str_sub(PoV,1,4)
PC1_t = str_c("PC1 (", PoV[1] , "%)")
PC2_t = str_c("PC2 (", PoV[2] ,"%)")

## Add patients metadata
bind_cols(data_pheno, pca$x) %>% 
ggplot(aes(x=PC1, y=PC2, shape=clinical_information, col=disease, label=individual)) + 
  geom_point() + 
  geom_text_repel() +
  labs(x = PC1_t , y = PC2_t, color = "Disease", shape = "Clinical information") 
```

### Heatmap (all genes)

In order to check if the data create individual clusters (experimental bias) and detect potential outliers.

```{r}
#| label: heatmap-individual

cor.matrix <- cor(data_counts)
annotations <- data_pheno |> select(disease, clinical_information)

heatmap.individual <- pheatmap(cor.matrix, 
         annotation_col = annotations,
         main = "Heatmap - All samples")

# save_pheatmap_pdf(heatmap.individual, file.path("../results/0X_heatmap-all-samples.pdf"))

## We can see 3 outliers in the heatmap and ACP

```

### Volcano plots

```{r}
#| label: heatmap-individual


```

## Gene set enrichment analysis (GSEA)

### Using fGSEA

```{r}
#| label: gsea
```
